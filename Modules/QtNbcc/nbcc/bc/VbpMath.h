#ifndef VBP_MATH_H
#define VBP_MATH_H

#include "../nb/nbc.h"
#include <math.h>

namespace Bc {
  using namespace Nb;

  //------------------------------------------------------------------------------
  //Математические преобразования над векторами дискретных и непрерывных параметров
  //------------------------------------------------------------------------------

  // Шаблон обмена значениями двух чисел
  template<class T>
  inline void mathSwap(T &x, T &y){
    T temp = x;
    x = y;
    y = temp;
  }

  // Быстрая сортировка массива
  // A        - [in/out] массив элементов, который нужно упорядочить
  // count    - [in]	   количество элементов
  void mathQSort(float A[], uint32_t count);
  void mathQSort(int32_t A[], uint32_t nelms);

  // Быстрая сортировка массива по возрастанию
  // A    - [in/out]	массив элементов, который нужно упорядочить
  // P		- [in]		  массив указателей, который связан с А и сортируется вместе с ним, т.е. сортируем только А, а P меняем так же
  // count    - [in]		количество элементов
  void mathQSort(float A[], void* P[], uint32_t count);
  void mathQSort(int32_t A[], float P[], uint32_t count);


  inline int sign(float x){
    if (x>0.0f) return 1;
    else if (x<0.0f) return -1;
    return 0;
  }

  inline int sign2(float x){
    if (x>0.0f) return 1;
    else return -1;
  }

  inline int sign(int32_t x){
    if (x>0) return 1;
    else if (x<0) return -1;
    return 0;
  }

  //Округление с заданной точностью
  // x -  [in] округляемое значение
  // digits - [in] количество цифр после нуля
  float roundUp( float x, int32_t digits );

  //Округление к ближайшему целому
  inline float roundNearest(float x){
    return (x>=0)?floor(x+0.5f):ceil(x-0.5f);
  }


  //Вычисление корреляции между двумя столбцами векторов
  //  w     - [вх] первый набор векторов вещественных значений
  //  w2    - [вх] второй набор векторов вещественных значений
  //  ncols - [вх] число примеров
  //  ie    - [вх] номер столбца первого набора
  //  ie2   - [вх] номер столбца второго набора
  float corrColR32( const Vbp *w, const Vbp *w2, uint32_t ncols, uint32_t ie, uint32_t ie2);

  //Вычисление перекрестной корреляции между примерами по столбцам
  //  Вычисление перекрестной корреляции осуществляется путем построения
  //  расчета таблицы вычисления корреляции "каждого с каждым" вектора
  //  подаваемого на вход набора векторов вещественных значений
  //  С целью экономии ресурсов рассчитываются только
  //  левый верхний треугольник корреляции матрицы (nelms*nelms)
  //  w       - [вх] набор векторов вещественных значений
  //  ncols   - [вх] число примеров в наборе
  //  nelms   - [вх] число элементов в наборе
  //  corr    - [вых] вектор вещественных значений корреляции из nelms*(nelms-1)/2 значений
  void corrColCrossR32(const Vbp *w, uint32_t ncols, uint32_t nelms, Vbp &corr);

  // Вычисление стойкости к атакам подбора
  float qual2Stab (float qual);

  //.............................................................................
  //  Статистические функции для вещественных векторов значений
  //.............................................................................

  //Вычисление среднего значения по вектору
  //  w       - [вх] набор векторов коэффициентов
  //  nelms   - [вх] число элементов вектора
  float averR32(const Vbp &w, uint32_t nelms);

  //Вычисление дисперсии по вектору
  //  w       - [вх] набор векторов коэффициентов
  //  nelms   - [вх] число элементов вектора
  //  aver    - [вх] расчетное математическое ожидание этого же столбца
  float dispR32(const Vbp &w, uint32_t nelms, float aver);

  //Вычисление качества
  //  aver    - [вх] расчетное математическое ожидание
  //  disp    - [вх] расчетное качество
  float qualR32(float aver, float disp);

  //Вычисление математического ожидания, дисперсии и качества для столбца набора векторов
  void adqR32(const Vbp &w, uint32_t nelms, float &a, float &d, float &q);

  //Вычисление среднего значения по столбцу
  //  w       - [вх] набор векторов коэффициентов
  //  ncols   - [вх] число примеров
  //  ielm    - [вх] индекс элемента, для которого рассчитывается значение
  float averColR32(const Vbp *w, uint32_t ncols, uint32_t ielm);

  //Вычисление дисперсии по столбцу
  //  w       - [вх] набор векторов коэффициентов
  //  ncols   - [вх] число примеров
  //  ielm    - [вх] индекс элемента, для которого рассчитывается значение
  //  aver    - [вх] расчетное математическое ожидание этого же столбца
  float dispColR32(const Vbp *w, uint32_t ncols, uint32_t ielm, float aver);

  //Вычисление математического ожидания, дисперсии и качества для столбца набора векторов
  void adqColR32(const Vbp *w, uint32_t ncols, uint32_t ielm, float &a, float &d, float &q);

  //Вычисление математического ожидания, дисперсии и качества для каждого примера входного параметра
  //  w       - [вх] набор примеров, представленных векторами вещественных чисел
  //  ncols   - [вх] число примеров
  //  nelms   - [вх] число элементов вектора
  //  a,d,q   - [вых] статистические характеристики (r32[nelms])
  void adqColR32(const Vbp *w, uint32_t ncols, uint32_t nelms, Vbp &a, Vbp &d, Vbp &q);

  //Поиск минимального значения целочисленного вектора
  float minR32(const Vbp &w, uint32_t nelms, uint32_t &imin);

  //Поиск максимального значения целочисленного вектора
  float maxR32(const Vbp &w, uint32_t nelms, uint32_t &imax);

  //Поиск максимального значения по модулю
  float amaxR32(const Vbp &w, uint32_t nelms, uint32_t &imax);

  //Вычисление стабильности, уникальности и качества для соответствующих
  //элементов векторов
  //  aown      - [вх] математическое ожидание "Свой"
  //  down      - [вх] дисперсия "Свой"
  //  aall      - [вх] математическое ожидание "Все чужие"
  //  dall      - [вх] дисперсия "Все чужие"
  //  ncols     - [вх] число элементов
  //  s         - [вых] стабильность
  //  o         - [вых] уникальность
  //  q         - [вых] качество
  void soqColR32( const Vbp &aown, const Vbp &down, const Vbp &aall, const Vbp & dall,
                  uint32_t ncols, float &s, float &o, float &q);

  //Предобработка обучающих примеров
  //  После работы функции может измениться количество образов и коэффициенты,
  //  т.к. выбросим "плохие примеры"
  //  В результирующем векторе коэффициентов coefs образы упорядочены следующим образом:
  //  чем ближе образ к среднему, тем ближе он к началу, т.е. вначале идут образы из
  //  центра области Свой, а последний - с края области Свой.
  //
  //  w         - [вх] набор векторов r32[ncols][nelms]
  //  ncols     - [вх] число векторов w
  //  nelms     - [вх] число элементов в одном векторе w
  //  wbetter   - [вых] набор нулевых векторов, в который будет занесены
  //                    указатели на отсортированные по возрастанию ge вектора w.
  //                    r32[ncols] = null
  //              (память должна быть выделена только под массив указателей)
  //  nbetter   - [вых] число "хороших" векторов
  //  ge        - [вых] одиночный вектор, с ранжирующими значениями (r32[nelms])
  bool geR32(const Vbp *w, uint32_t ncols, uint32_t nelms, Vbp *wbetter, uint32_t &nbetter, Vbp &ge);

  //.............................................................................
  //  Статистические функции для целых векторов значений
  //.............................................................................

  //Вычисление среднего значения по вектору бит
  //  w         - [вх] набор векторов коэффициентов
  //  ncols     - [вх] число векторов коэффициентов
  //  ielm      - [вх] номер элемента вектора
  float averColU1(const Vbp *w, uint32_t ncols, uint32_t ielm);

  //Вычисление среднего значения по вектору
  //  w         - [вх] вектор коэффициентов
  //  nelms     - [вх] число элементов вектора
  float averI32(const Vbp &w, uint32_t nelms);

  //Вычисление дисперсии по вектору
  //  w         - [вх] набор векторов коэффициентов
  //  nelms     - [вх] число элементов вектора
  //  aver      - [вх] расчетное математическое ожидание этого же столбца
  float dispI32(const Vbp &w, uint32_t nelms, float aver);

  //Вычисление качества
  //  aver      - [вх] расчетное математическое ожидание
  //  disp      - [вх] расчетное качество
  float qualI32(float aver, float disp);

  //Поиск минимального значения целочисленного вектора
  int32_t minI32(const Vbp &w, uint32_t nelms, uint32_t &imin);

  //Поиск максимального значения целочисленного вектора
  int32_t maxI32(const Vbp &w, uint32_t nelms, uint32_t &imax);

  //Подсчет числа нулей в векторе
  uint32_t cumNilI32(const Vbp &w, uint32_t nelms);

  //Вычисление характеристик для вектора целочисленных значений
  void adqI32(const Vbp &w, uint32_t nelms, float &a, float &d, float &q);

  //Подсчет отличий между векторами бит
  uint32_t hammU1(const Vbp &w, const Vbp &w2, uint32_t nelms);
  uint32_t hammR32(const Vbp &w, const Vbp &w2, uint32_t nelms);

  //Подсчет отличающихся знаков
  uint32_t diffsSignR32(const Vbp &w, float s, uint32_t nelms);

  // Вычисление вероятности (со знаком) распределения относительно начала координат
  // aver - [in] математическое ожидание распределения
  // disp - [in] стандартное отклонение
  // a    - [in] левая граница интервала
  // b    - [in] правая граница интервала
  // возвращает: значение вероятности
  float probNormR32(float aver, float disp, float a, float b);
  void probNormR32(const Vbp &aver, const Vbp &disp, uint32_t nelms, float a, float b, Vbp &prob);

}

#endif // BC_MATH_H
