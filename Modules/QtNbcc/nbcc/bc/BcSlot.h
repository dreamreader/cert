#ifndef BC_SLOT_H
#define BC_SLOT_H

#include "../nb/nbc.h"

#pragma pack(1)

namespace Bc {

  using namespace Nb;

  class BcScheme;
  class BcSlot;
  typedef QList<BcSlot*> BcSlots;

  //...............................................................................
  //Слот преобразования
  //...............................................................................
  class BcSlot: public Slot {
  public:
    BcSlot();
    virtual ~BcSlot();

    //Доступ к данным ограничения
    //ct        - тип ограничения
    //примечание: по умолчанию доступны 5 типов ограничений CtAny, CtAll, CtOwn, CtTst, CtGe, иначе возвращается пустая строка
    virtual Matrix::Row constraint(ConstraintType ct) const;

    //Сброс всех имеющихся ограничений данных
    virtual bool clear();
    //Сброс ограничений по типу
    //ct        - тип ограничения
    //physical  - физически удалить или просто отсоединить присоединенный
    virtual bool clear(ConstraintType ct);
    //Запись ограничения
    //примечание: при отсутствии данных, запись не проводится
    virtual bool set(ConstraintType ct, const Matrix::Row &value);
    //Чтение огранчения
    //примечание: копируются первые actual элементов
    virtual bool get(ConstraintType ct, Matrix::Row &value) const;
    //Проверка актуального состояния
    //возвращает: число установленных примеров
    virtual int32_t actual(ConstraintType ct) const;


    //Сброс состояния в необученное (и установленных параметров)
    virtual bool reset();
    //Обучение блока с параметрами, определенными в присоединенном слоте
    //Примечание:
    //  1. используются плоскости own и all
    //  2. не установленные параметры вычисляются или генерируются в соответствии
    //      с установленными флагами
    //  3. число сгенерированных во время обучения входных параметров
    //      может не совпадать с числом вычисленных с помощью extract
    virtual bool train(TrainMode mode, BlockState state, BlockFlags flags)=0;
    //Эмуляция с параметрами, определенными в присоединенном слоте
    //  cti   - [вх]  плоскость вх. и сп.вх. данных
    //  cto   - [вх] плоскость вых. и сп.вых. данных
    //  recur - [вх] флаг использования рекурсии для вычисления входных параметров
    //Примечание:
    //  1. результат записывается в выходную плоскость
    //  2. число примеров вх., сп.вх. параметров должно быть одинаковым
    //  3. число примеров на выходе будет соответствовать числу входных параметров
    //  4. контроль метаописаний параметров плоскостей проводится извне, т.е.
    //      при передаче плоскостей Ge и Tst возникнет ошибка
    virtual bool emulate(ConstraintType cti=CtAny, ConstraintType cto=CtAny, bool recur=false)=0;
    //Обнаружение больших отклонений от нормы примеров "Свой"
    //примечания:
    //  1. при объединении по входам полагается,
    //      что примеры "Свой" с одинаковыми номерам коррелированы,
    //     при объединении по выходам полагается,
    //      что примеры "Свой" с одинаковыми номерами некоррелированы
    //  2. для вычисления интегрального показателя качества используются среднее
    //      значение качества, взятое пропорционально числу параметров
    //  3. для независимых образов (при мультибиометрическом слиянии)
    //      показатели должны вычисляться по очереди
    //результат доступен через CtGe
    virtual bool qeval();

    //Тестирование слота с целью вычисления его P2 (P1 должно вычисляться опытным путем)
    //примечания:
    //  1.для слотов преобразования (нейросетевого и т.д.) находятся приблизительные значения показателей
    //  2.для индикаторов определяется показатель ослабления
    //  3.для трансформирующих и связывающих показателей находится показатель усиления
    //  4.для альтернативного преобразователя выбирается показатель минимального значения
    //  5.для слотов параметров возвращается реальная стойкость секрета с учетом корреляции "Все чужие" и "Свой"
    //результат доступен через CtTst
    virtual bool test()=0;

    //Сохранение параметров в блок
    //примечание: блок(и) добавляе(ю)тся последовательно в конец контейнера
    //            в зависимости от состояния родительской схемы (SsScheme, SsTrained) выполняется сохранение параметров
    //возвращает: число считанных блоков или -1
    virtual int32_t writeParams(Container &c, const Uuid *ct=Null, const BlockType *bt=Null) const=0;

    //Импорт параметров из блока
    //возвращает: число считанных блоков или -1
    virtual int32_t readParams(const Container &c, int32_t pos, const Uuid *ct=Null)=0;


    //Проверка слота в пределах S-схемы
    //virtual bool validate() const;
    //Проверка слота с учетом R-схемы
    //virtual bool rvalidate() const;
    //Обновление связей при установке S-схемы
    virtual bool update();
    //Обновление связей при установке R-схемы
    virtual bool rupdate();
    //Синхронизация состояний связанных слотов
    virtual void sync();
  protected:
    inline BcSlot* con(int32_t pos){ return _cons[pos]; } //Доступ к связанному слоту по номеру
    inline const BcSlot* con(int32_t pos) const { return _cons[pos]; } //Доступ к связанному слоту по номеру

    //Разделение списка слотов по типу
    //  si  - [вх] входные
    //  ssi - [вх] специальные входные
    //  sso - [вх] специальные выходные
    //  so  - [вх] выходной (собственый слот)
    //примечание: используется операция добавления в список, поэтому
    //            можно подавать один и тот же список в несколько слотов
    void cons(BcSlots *si, BcSlots *ssi=Null, BcSlots *sso=Null, BcSlots *so=Null) const ;

    //Получение списка данных по списку слотов и типу данных
    static Matrix::Rows& constraints(const BcSlots &ss, ConstraintType ct, Matrix::Rows &rr);

    //Актуализация состояния зависимых слотов
    //  cons  - [вх] список зависимых слотов
    //  ct    - [вх] тип ограничения
    //  ncols - [вых] число параметров (должно быть одинаково у всех слотов)
    //  emul  - [вх] флаг необходимости эмуляции
    //возвращает: true, если все параметры найдены и ncols одинаково
    virtual bool actualize(BcSlots &cons, ConstraintType ct, int32_t &ncols, bool emul);

    //Подготовка параметров к преобразованию путем выделения памяти
    //  cons  - [вх] список вычисляемых слотов
    //  ct    - [вх] тип ограничения
    //  ncols - [вых] число вычисляемых параметров
    //возвращает: true, если память под вычисления подготовлена
    virtual bool prepare(BcSlots &cons, ConstraintType ct, int32_t ncols);

    //Проверка преобразователя
    inline bool isConvertor() const { return (_id.type() == StOut); }
    //Проверка на мультипреобразователь
    inline bool isNested() const { return (_cons.count() && _refs.count()); }
    //Проверка связанности с некоторым отображенным слотом внешней или вложенной схемы
    //примечание: слоты сп.вых. всегда ссылаются на вложенные слоты
    //            слоты вх., сп.вх. всегда ссылаются на внешние слоты
    inline bool isReferred() const { return (!_cons.count() && _refs.count()); }

    inline BcSlot* ref() const { return _refs[_refs.count()-2];}    //Ссылка на отображенный слот
    inline BcSlot* refm() const { return _refs[_refs.count()-1];}   //Ссылка на связывающий вложенный преобразователь
  protected:
    friend class BcScheme;
    BcSlots     _cons;    //список связанных слотов по _cids, ссылок на вычисляемые данные (вызываемые слоты)
    BcSlots     _refs;    //список отображенных слотов по _rids
    Matrix      _data[5]; //вектора результатов вычислений (доступ по индексу ConstraintType)
  };

}

#pragma pack()
#endif // BC_SLOT_H
