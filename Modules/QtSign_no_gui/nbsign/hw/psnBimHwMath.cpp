/****************************************************************************
** файл:        psnBimHwMath.cpp
** версия:
** дата:        24.03.2007
** изменен:
** автор:       Майоров А.В., Захаров О.С.
**
** описание:    Преобразование биометрических рукописных образов,
**              быстрое неоптимизированное преобразование Фурье.
****************************************************************************/

#include "psnBimHwMath.h"

#define MATH_PI	3.1415926f        // pi
#define NIL     0
#define FNIL    0.0f

// Таблица синусов (для быстрых вычислений)
const float gTableSin[psnHW_SCALE_COUNT] = {
	0.00000000f,	0.01227154f,	0.02454123f,	0.03680722f,	0.04906768f,	0.06132074f,	0.07356457f,	0.08579732f,	
	0.09801714f,	0.11022221f,	0.12241068f,	0.13458072f,	0.14673048f,	0.15885815f,	0.17096189f,	0.18303989f,	
	0.19509032f,	0.20711139f,	0.21910125f,	0.23105812f,	0.24298018f,	0.25486568f,	0.26671275f,	0.27851969f,	
	0.29028469f,	0.30200595f,	0.31368175f,	0.32531029f,	0.33688986f,	0.34841868f,	0.35989505f,	0.37131721f,	
	0.38268346f,	0.39399204f,	0.40524131f,	0.41642958f,	0.42755511f,	0.43861625f,	0.44961134f,	0.46053872f,	
	0.47139674f,	0.48218378f,	0.49289820f,	0.50353837f,	0.51410276f,	0.52458972f,	0.53499764f,	0.54532498f,	
	0.55557024f,	0.56573182f,	0.57580823f,	0.58579785f,	0.59569931f,	0.60551107f,	0.61523163f,	0.62485951f,	
	0.63439327f,	0.64383155f,	0.65317285f,	0.66241580f,	0.67155898f,	0.68060100f,	0.68954057f,	0.69837624f,	
	0.70710677f,	0.71573085f,	0.72424710f,	0.73265427f,	0.74095112f,	0.74913639f,	0.75720888f,	0.76516730f,	
	0.77301049f,	0.78073722f,	0.78834647f,	0.79583693f,	0.80320758f,	0.81045723f,	0.81758481f,	0.82458931f,	
	0.83146966f,	0.83822471f,	0.84485358f,	0.85135520f,	0.85772860f,	0.86397284f,	0.87008703f,	0.87607008f,	
	0.88192129f,	0.88763964f,	0.89322430f,	0.89867449f,	0.90398932f,	0.90916800f,	0.91420978f,	0.91911387f,	
	0.92387956f,	0.92850608f,	0.93299282f,	0.93733901f,	0.94154406f,	0.94560736f,	0.94952822f,	0.95330608f,	
	0.95694035f,	0.96043050f,	0.96377605f,	0.96697646f,	0.97003126f,	0.97293997f,	0.97570217f,	0.97831738f,	
	0.98078531f,	0.98310548f,	0.98527765f,	0.98730141f,	0.98917651f,	0.99090266f,	0.99247956f,	0.99390697f,	
	0.99518472f,	0.99631262f,	0.99729043f,	0.99811810f,	0.99879545f,	0.99932241f,	0.99969882f,	0.99992472f,	
	1.00000000f,	0.99992472f,	0.99969882f,	0.99932235f,	0.99879545f,	0.99811810f,	0.99729043f,	0.99631262f,	
	0.99518472f,	0.99390697f,	0.99247950f,	0.99090260f,	0.98917651f,	0.98730141f,	0.98527765f,	0.98310548f,	
	0.98078525f,	0.97831738f,	0.97570211f,	0.97293997f,	0.97003126f,	0.96697646f,	0.96377605f,	0.96043050f,	
	0.95694029f,	0.95330602f,	0.94952816f,	0.94560730f,	0.94154406f,	0.93733901f,	0.93299276f,	0.92850608f,	
	0.92387950f,	0.91911381f,	0.91420972f,	0.90916795f,	0.90398926f,	0.89867443f,	0.89322430f,	0.88763958f,	
	0.88192123f,	0.87607008f,	0.87008697f,	0.86397284f,	0.85772860f,	0.85135514f,	0.84485352f,	0.83822465f,	
	0.83146960f,	0.82458925f,	0.81758475f,	0.81045717f,	0.80320752f,	0.79583687f,	0.78834641f,	0.78073716f,	
	0.77301043f,	0.76516724f,	0.75720882f,	0.74913633f,	0.74095106f,	0.73265421f,	0.72424704f,	0.71573079f,	
	0.70710671f,	0.69837618f,	0.68954051f,	0.68060094f,	0.67155892f,	0.66241574f,	0.65317279f,	0.64383149f,	
	0.63439322f,	0.62485945f,	0.61523151f,	0.60551101f,	0.59569925f,	0.58579779f,	0.57580811f,	0.56573176f,	
	0.55557019f,	0.54532492f,	0.53499758f,	0.52458960f,	0.51410270f,	0.50353831f,	0.49289814f,	0.48218369f,	
	0.47139668f,	0.46053866f,	0.44961128f,	0.43861616f,	0.42755502f,	0.41642949f,	0.40524125f,	0.39399198f,	
	0.38268337f,	0.37131712f,	0.35989496f,	0.34841859f,	0.33688977f,	0.32531023f,	0.31368166f,	0.30200589f,	
	0.29028460f,	0.27851960f,	0.26671270f,	0.25486559f,	0.24298011f,	0.23105803f,	0.21910116f,	0.20711130f,	
	0.19509023f,	0.18303981f,	0.17096181f,	0.15885806f,	0.14673039f,	0.13458063f,	0.12241060f,	0.11022212f,	
	0.09801706f,	0.08579723f,	0.07356448f,	0.06132065f,	0.04906759f,	0.03680713f,	0.02454114f,	0.01227145f,	
	-0.00000009f,	-0.01227163f,	-0.02454132f,	-0.03680731f,	-0.04906776f,	-0.06132083f,	-0.07356466f,	-0.08579740f,	
	-0.09801723f,	-0.11022229f,	-0.12241077f,	-0.13458081f,	-0.14673057f,	-0.15885824f,	-0.17096198f,	-0.18303998f,	
	-0.19509041f,	-0.20711146f,	-0.21910132f,	-0.23105820f,	-0.24298027f,	-0.25486577f,	-0.26671284f,	-0.27851978f,	
	-0.29028478f,	-0.30200604f,	-0.31368184f,	-0.32531038f,	-0.33688995f,	-0.34841877f,	-0.35989514f,	-0.37131730f,	
	-0.38268352f,	-0.39399213f,	-0.40524140f,	-0.41642964f,	-0.42755517f,	-0.43861634f,	-0.44961143f,	-0.46053880f,	
	-0.47139683f,	-0.48218387f,	-0.49289829f,	-0.50353849f,	-0.51410282f,	-0.52458978f,	-0.53499770f,	-0.54532510f,	
	-0.55557030f,	-0.56573188f,	-0.57580829f,	-0.58579797f,	-0.59569937f,	-0.60551113f,	-0.61523169f,	-0.62485957f,	
	-0.63439339f,	-0.64383161f,	-0.65317291f,	-0.66241586f,	-0.67155904f,	-0.68060106f,	-0.68954062f,	-0.69837630f,	
	-0.70710683f,	-0.71573091f,	-0.72424716f,	-0.73265433f,	-0.74095118f,	-0.74913645f,	-0.75720894f,	-0.76516736f,	
	-0.77301055f,	-0.78073728f,	-0.78834647f,	-0.79583699f,	-0.80320758f,	-0.81045729f,	-0.81758487f,	-0.82458937f,	
	-0.83146966f,	-0.83822477f,	-0.84485364f,	-0.85135525f,	-0.85772866f,	-0.86397290f,	-0.87008703f,	-0.87607014f,	
	-0.88192129f,	-0.88763970f,	-0.89322436f,	-0.89867449f,	-0.90398932f,	-0.90916800f,	-0.91420978f,	-0.91911387f,	
	-0.92387956f,	-0.92850614f,	-0.93299282f,	-0.93733907f,	-0.94154412f,	-0.94560736f,	-0.94952822f,	-0.95330608f,	
	-0.95694035f,	-0.96043056f,	-0.96377611f,	-0.96697652f,	-0.97003126f,	-0.97293997f,	-0.97570217f,	-0.97831738f,	
	-0.98078531f,	-0.98310554f,	-0.98527765f,	-0.98730141f,	-0.98917651f,	-0.99090266f,	-0.99247956f,	-0.99390697f,	
	-0.99518472f,	-0.99631262f,	-0.99729049f,	-0.99811810f,	-0.99879545f,	-0.99932241f,	-0.99969882f,	-0.99992472f,	
	-1.00000000f,	-0.99992472f,	-0.99969882f,	-0.99932235f,	-0.99879545f,	-0.99811810f,	-0.99729043f,	-0.99631262f,	
	-0.99518472f,	-0.99390697f,	-0.99247950f,	-0.99090260f,	-0.98917651f,	-0.98730141f,	-0.98527759f,	-0.98310548f,	
	-0.98078525f,	-0.97831732f,	-0.97570211f,	-0.97293991f,	-0.97003120f,	-0.96697646f,	-0.96377605f,	-0.96043050f,	
	-0.95694029f,	-0.95330602f,	-0.94952816f,	-0.94560730f,	-0.94154400f,	-0.93733895f,	-0.93299276f,	-0.92850602f,	
	-0.92387950f,	-0.91911381f,	-0.91420972f,	-0.90916795f,	-0.90398926f,	-0.89867443f,	-0.89322424f,	-0.88763958f,	
	-0.88192117f,	-0.87607002f,	-0.87008691f,	-0.86397278f,	-0.85772854f,	-0.85135514f,	-0.84485346f,	-0.83822465f,	
	-0.83146954f,	-0.82458919f,	-0.81758475f,	-0.81045711f,	-0.80320746f,	-0.79583681f,	-0.78834635f,	-0.78073716f,	
	-0.77301037f,	-0.76516718f,	-0.75720876f,	-0.74913627f,	-0.74095100f,	-0.73265415f,	-0.72424698f,	-0.71573073f,	
	-0.70710665f,	-0.69837612f,	-0.68954045f,	-0.68060088f,	-0.67155886f,	-0.66241568f,	-0.65317273f,	-0.64383143f,	
	-0.63439316f,	-0.62485939f,	-0.61523145f,	-0.60551089f,	-0.59569919f,	-0.58579773f,	-0.57580805f,	-0.56573170f,	
	-0.55557013f,	-0.54532486f,	-0.53499746f,	-0.52458954f,	-0.51410258f,	-0.50353825f,	-0.49289805f,	-0.48218364f,	
	-0.47139660f,	-0.46053857f,	-0.44961119f,	-0.43861610f,	-0.42755494f,	-0.41642940f,	-0.40524116f,	-0.39399189f,	
	-0.38268328f,	-0.37131703f,	-0.35989487f,	-0.34841853f,	-0.33688968f,	-0.32531014f,	-0.31368157f,	-0.30200580f,	
	-0.29028451f,	-0.27851954f,	-0.26671261f,	-0.25486550f,	-0.24298002f,	-0.23105794f,	-0.21910107f,	-0.20711121f,	
	-0.19509016f,	-0.18303972f,	-0.17096172f,	-0.15885797f,	-0.14673030f,	-0.13458054f,	-0.12241051f,	-0.11022203f,	
	-0.09801697f,	-0.08579714f,	-0.07356439f,	-0.06132056f,	-0.04906750f,	-0.03680705f,	-0.02454105f,	-0.01227136f	
};

// Таблица косинусов (для быстрых вычислений)
const float gTableCos[psnHW_SCALE_COUNT] = {
	1.00000000f,	0.99992472f,	0.99969882f,	0.99932235f,	0.99879545f,	0.99811810f,	0.99729043f,	0.99631262f,	
	0.99518472f,	0.99390697f,	0.99247956f,	0.99090266f,	0.98917651f,	0.98730141f,	0.98527765f,	0.98310548f,	
	0.98078525f,	0.97831738f,	0.97570211f,	0.97293997f,	0.97003126f,	0.96697646f,	0.96377605f,	0.96043050f,	
	0.95694035f,	0.95330602f,	0.94952816f,	0.94560730f,	0.94154406f,	0.93733901f,	0.93299282f,	0.92850608f,	
	0.92387950f,	0.91911387f,	0.91420972f,	0.90916800f,	0.90398932f,	0.89867449f,	0.89322430f,	0.88763964f,	
	0.88192123f,	0.87607008f,	0.87008697f,	0.86397284f,	0.85772860f,	0.85135520f,	0.84485358f,	0.83822471f,	
	0.83146960f,	0.82458931f,	0.81758481f,	0.81045717f,	0.80320752f,	0.79583687f,	0.78834641f,	0.78073722f,	
	0.77301043f,	0.76516724f,	0.75720882f,	0.74913639f,	0.74095112f,	0.73265427f,	0.72424710f,	0.71573079f,	
	0.70710677f,	0.69837624f,	0.68954051f,	0.68060100f,	0.67155892f,	0.66241574f,	0.65317285f,	0.64383155f,	
	0.63439327f,	0.62485945f,	0.61523157f,	0.60551101f,	0.59569931f,	0.58579785f,	0.57580817f,	0.56573176f,	
	0.55557019f,	0.54532498f,	0.53499758f,	0.52458966f,	0.51410270f,	0.50353837f,	0.49289817f,	0.48218375f,	
	0.47139671f,	0.46053869f,	0.44961131f,	0.43861622f,	0.42755505f,	0.41642952f,	0.40524128f,	0.39399201f,	
	0.38268340f,	0.37131718f,	0.35989499f,	0.34841865f,	0.33688983f,	0.32531026f,	0.31368172f,	0.30200592f,	
	0.29028463f,	0.27851966f,	0.26671273f,	0.25486562f,	0.24298014f,	0.23105808f,	0.21910121f,	0.20711134f,	
	0.19509028f,	0.18303984f,	0.17096186f,	0.15885811f,	0.14673044f,	0.13458067f,	0.12241063f,	0.11022217f,	
	0.09801710f,	0.08579727f,	0.07356452f,	0.06132070f,	0.04906763f,	0.03680718f,	0.02454119f,	0.01227149f,	
	-0.00000004f,	-0.01227158f,	-0.02454127f,	-0.03680727f,	-0.04906772f,	-0.06132078f,	-0.07356461f,	-0.08579735f,	
	-0.09801719f,	-0.11022225f,	-0.12241072f,	-0.13458076f,	-0.14673053f,	-0.15885819f,	-0.17096193f,	-0.18303993f,	
	-0.19509037f,	-0.20711142f,	-0.21910129f,	-0.23105815f,	-0.24298023f,	-0.25486571f,	-0.26671281f,	-0.27851975f,	
	-0.29028472f,	-0.30200601f,	-0.31368178f,	-0.32531035f,	-0.33688989f,	-0.34841874f,	-0.35989508f,	-0.37131724f,	
	-0.38268349f,	-0.39399210f,	-0.40524137f,	-0.41642961f,	-0.42755514f,	-0.43861628f,	-0.44961137f,	-0.46053877f,	
	-0.47139677f,	-0.48218381f,	-0.49289826f,	-0.50353843f,	-0.51410282f,	-0.52458972f,	-0.53499764f,	-0.54532504f,	
	-0.55557030f,	-0.56573188f,	-0.57580823f,	-0.58579791f,	-0.59569937f,	-0.60551107f,	-0.61523163f,	-0.62485951f,	
	-0.63439333f,	-0.64383161f,	-0.65317291f,	-0.66241580f,	-0.67155898f,	-0.68060106f,	-0.68954057f,	-0.69837630f,	
	-0.70710683f,	-0.71573085f,	-0.72424716f,	-0.73265433f,	-0.74095118f,	-0.74913645f,	-0.75720888f,	-0.76516730f,	
	-0.77301049f,	-0.78073728f,	-0.78834647f,	-0.79583693f,	-0.80320758f,	-0.81045723f,	-0.81758487f,	-0.82458937f,	
	-0.83146966f,	-0.83822477f,	-0.84485358f,	-0.85135525f,	-0.85772866f,	-0.86397290f,	-0.87008703f,	-0.87607014f,	
	-0.88192129f,	-0.88763964f,	-0.89322436f,	-0.89867449f,	-0.90398932f,	-0.90916800f,	-0.91420978f,	-0.91911387f,	
	-0.92387956f,	-0.92850614f,	-0.93299282f,	-0.93733907f,	-0.94154412f,	-0.94560736f,	-0.94952822f,	-0.95330608f,	
	-0.95694035f,	-0.96043056f,	-0.96377611f,	-0.96697646f,	-0.97003126f,	-0.97293997f,	-0.97570217f,	-0.97831738f,	
	-0.98078531f,	-0.98310548f,	-0.98527765f,	-0.98730141f,	-0.98917651f,	-0.99090266f,	-0.99247956f,	-0.99390697f,	
	-0.99518472f,	-0.99631262f,	-0.99729049f,	-0.99811810f,	-0.99879545f,	-0.99932241f,	-0.99969882f,	-0.99992472f,	
	-1.00000000f,	-0.99992472f,	-0.99969882f,	-0.99932235f,	-0.99879545f,	-0.99811810f,	-0.99729043f,	-0.99631262f,	
	-0.99518472f,	-0.99390697f,	-0.99247950f,	-0.99090260f,	-0.98917651f,	-0.98730141f,	-0.98527765f,	-0.98310548f,	
	-0.98078525f,	-0.97831738f,	-0.97570211f,	-0.97293991f,	-0.97003120f,	-0.96697646f,	-0.96377605f,	-0.96043050f,	
	-0.95694029f,	-0.95330602f,	-0.94952816f,	-0.94560730f,	-0.94154406f,	-0.93733895f,	-0.93299276f,	-0.92850602f,	
	-0.92387950f,	-0.91911381f,	-0.91420972f,	-0.90916795f,	-0.90398926f,	-0.89867443f,	-0.89322424f,	-0.88763958f,	
	-0.88192123f,	-0.87607002f,	-0.87008697f,	-0.86397278f,	-0.85772854f,	-0.85135514f,	-0.84485352f,	-0.83822465f,	
	-0.83146954f,	-0.82458925f,	-0.81758475f,	-0.81045711f,	-0.80320746f,	-0.79583687f,	-0.78834635f,	-0.78073716f,	
	-0.77301037f,	-0.76516718f,	-0.75720876f,	-0.74913633f,	-0.74095106f,	-0.73265421f,	-0.72424698f,	-0.71573073f,	
	-0.70710671f,	-0.69837618f,	-0.68954045f,	-0.68060094f,	-0.67155886f,	-0.66241568f,	-0.65317273f,	-0.64383143f,	
	-0.63439322f,	-0.62485939f,	-0.61523151f,	-0.60551095f,	-0.59569919f,	-0.58579779f,	-0.57580811f,	-0.56573170f,	
	-0.55557013f,	-0.54532492f,	-0.53499752f,	-0.52458960f,	-0.51410264f,	-0.50353831f,	-0.49289808f,	-0.48218367f,	
	-0.47139663f,	-0.46053860f,	-0.44961122f,	-0.43861613f,	-0.42755499f,	-0.41642946f,	-0.40524119f,	-0.39399192f,	
	-0.38268331f,	-0.37131709f,	-0.35989493f,	-0.34841856f,	-0.33688974f,	-0.32531017f,	-0.31368163f,	-0.30200583f,	
	-0.29028457f,	-0.27851957f,	-0.26671264f,	-0.25486553f,	-0.24298006f,	-0.23105799f,	-0.21910112f,	-0.20711125f,	
	-0.19509020f,	-0.18303977f,	-0.17096177f,	-0.15885802f,	-0.14673035f,	-0.13458058f,	-0.12241055f,	-0.11022208f,	
	-0.09801701f,	-0.08579718f,	-0.07356443f,	-0.06132061f,	-0.04906755f,	-0.03680709f,	-0.02454110f,	-0.01227141f,	
	0.00000013f,	0.01227167f,	0.02454136f,	0.03680735f,	0.04906781f,	0.06132087f,	0.07356469f,	0.08579744f,	
	0.09801728f,	0.11022234f,	0.12241081f,	0.13458084f,	0.14673060f,	0.15885828f,	0.17096202f,	0.18304002f,	
	0.19509046f,	0.20711151f,	0.21910137f,	0.23105824f,	0.24298032f,	0.25486580f,	0.26671290f,	0.27851981f,	
	0.29028481f,	0.30200610f,	0.31368187f,	0.32531044f,	0.33688998f,	0.34841880f,	0.35989517f,	0.37131733f,	
	0.38268358f,	0.39399219f,	0.40524143f,	0.41642970f,	0.42755523f,	0.43861637f,	0.44961146f,	0.46053883f,	
	0.47139686f,	0.48218390f,	0.49289832f,	0.50353849f,	0.51410288f,	0.52458984f,	0.53499776f,	0.54532510f,	
	0.55557036f,	0.56573194f,	0.57580829f,	0.58579797f,	0.59569943f,	0.60551119f,	0.61523169f,	0.62485963f,	
	0.63439339f,	0.64383167f,	0.65317297f,	0.66241586f,	0.67155910f,	0.68060112f,	0.68954068f,	0.69837636f,	
	0.70710689f,	0.71573091f,	0.72424722f,	0.73265439f,	0.74095124f,	0.74913651f,	0.75720894f,	0.76516736f,	
	0.77301055f,	0.78073734f,	0.78834653f,	0.79583699f,	0.80320764f,	0.81045729f,	0.81758493f,	0.82458937f,	
	0.83146971f,	0.83822477f,	0.84485364f,	0.85135525f,	0.85772872f,	0.86397296f,	0.87008709f,	0.87607020f,	
	0.88192135f,	0.88763970f,	0.89322436f,	0.89867455f,	0.90398937f,	0.90916806f,	0.91420984f,	0.91911393f,	
	0.92387962f,	0.92850614f,	0.93299288f,	0.93733907f,	0.94154412f,	0.94560736f,	0.94952822f,	0.95330608f,	
	0.95694041f,	0.96043056f,	0.96377611f,	0.96697652f,	0.97003132f,	0.97293997f,	0.97570217f,	0.97831738f,	
	0.98078531f,	0.98310554f,	0.98527765f,	0.98730147f,	0.98917651f,	0.99090266f,	0.99247956f,	0.99390697f,	
	0.99518472f,	0.99631262f,	0.99729049f,	0.99811810f,	0.99879545f,	0.99932241f,	0.99969882f,	0.99992472f	
};

//назначение: приведение выборки к новому масштабу dpi2
//параметры:
//  pt       - [вх]  выборка из произвольного числа элементов
//  ptCount  - [вх]  число элементов в выборке
// 
void scaleHwByDpi(nbPointHw *pt,  uint32_t ptCount, uint16_t dpiX, uint16_t dpiX2, uint16_t dpiY, uint16_t dpiY2) {
  float kX = (float)dpiX2/dpiX;
  float kY = (float)dpiY2/dpiY;
  for (uint32_t i = 0; i < ptCount; ++i) {
    pt[i].x = (uint16_t)((float)pt[i].x*kX);
    pt[i].y = (uint16_t)((float)pt[i].y*kY);
  }
}

//назначение: масштабирование выборки до 512 элементов пропорционально времени
//            ввода и обратно-пропорционально среднему давлению
//примечания:  
//  Известно предварительно, что образ содержит хотя бы 2 точки с ненулевым давлением
//  В каждой точке: 
//    поля x и y хранят координаты пера
//    поле p хранит давление пера, нулевое значение означает разрыв
//    поле t хранит интервал времени в мс между текущей и предшествующей точками
//  Недостатком формулы учета давления является то, что коэффициент для x и y одинаковый, 
//  значит, сохраняет корреляцию между x и y. 
//параметры:
//  pt       - [вх]  выборка из произвольного числа элементов
//  ptCount  - [вх]  число элементов в выборке
//  pt2      - [вых] результирующая выборка из 512 элементов
//
void scaleHwTo512(const nbPointHw *pt,  uint32_t ptCount, nbPointHw *pt2) {
  // Обнулить массив точек
  memset(pt2,NIL,psnHW_SCALE_COUNT*sizeof(nbPointHw));

  // Найти первую ненулевую точку интервала и ее время, относительно начала образа
  uint32_t f  = NIL;        // индекс первой точки
  while (pt[f].p == NIL){ ++f; }

  // Найти последнюю ненулевую точку интервала и ее время, относительно конца образа
  uint32_t e  = ptCount-1;  // индекс последней точки
  while (pt[e].p == NIL){ --e; }

  // Рассчитать время между 2-мя найденными точками и найти 1/512 интервала этого времени
  uint32_t fet = NIL;       // время между первой и последней точкой образа
  for (uint32_t i=f+1; i<=e; ++i){ fet += pt[i].t; }
  float dt = (float)fet/(float)psnHW_SCALE_COUNT;

  // Сохранить первую и последнюю точку без изменений в выходной массив
  pt2[NIL].x = (uint16_t)pt[f].x; 
  pt2[NIL].y = (uint16_t)pt[f].y;
  pt2[NIL].p = (uint16_t)pt[f].p;
  pt2[psnHW_SCALE_COUNT-1].x = (uint16_t)pt[e].x;
  pt2[psnHW_SCALE_COUNT-1].y = (uint16_t)pt[e].y;
  pt2[psnHW_SCALE_COUNT-1].p = (uint16_t)pt[e].p;

  // Задать начальные точки интервала интерполяции
  uint32_t h = f;       // верхняя граничная точка интервала
  uint32_t l = NIL;     // нижняя граничная точка интервала
  uint32_t ht= NIL;     // время верхней граничной точки, относительно начала
  uint32_t lt= NIL;     // время нижней граничной точки, относительно начала

  for (uint32_t i=1;i<(psnHW_SCALE_COUNT-1); ++i) {
    float ct = dt*i;  //текущее время точки pt2[i]
    // Найти верхнюю точку интервала, пропустив все точки проноса
    while (pt[h].p==NIL || ht<=ct) { ++h; ht += pt[h].t; }
    // Найти нижнюю точку интервала, относительно верхней, пропустив все точки проноса
    l = h;
    lt= ht;
    while (pt[l].p==NIL || lt>ct) { lt -= pt[l].t; --l; }

    float dr = (float)(ht-ct);  // время между верхним и текущим
    float dl = (float)(ct-lt);  // время между текущим и нижним
    float dd = (float)(ht-lt);  // исходный интервал времени между верхним и нижним

    pt2[i].x = (uint16_t)((dr*pt[l].x + dl*pt[h].x)/dd);
    pt2[i].y = (uint16_t)((dr*pt[l].y + dl*pt[h].y)/dd);
    pt2[i].p = (uint16_t)((dr*pt[l].p + dl*pt[h].p)/dd);
  }
}

//назначение: нормализация значений по известному среднему и дисперсии нормального
//            распределения (могут использоваться характеристики базы "Все чужие")
//параметры:
//  w      - [вх/вых] нормализуемый вектор
//  aver   - [вх] вектор средних значений
//  disp   - [вх] вектор дисперсий
//  eCount - [вх] число элементов в каждом из векторов
//  shift  - [вх] смещение в нормализуемом векторе
//
void normR32(Vbp &w, const Vbp &aver, const Vbp &disp, uint32_t eCount, uint32_t shift) {
  for (uint32_t i = 0; i < eCount; ++i) {
    w.r32[i+shift] = (w.r32[i+shift]-aver.r32[i])/disp.r32[i];
  }
}

//назначение: сдвиг начала образа в нулевую точку
//параметры:
//  pt      - [вх/вых] набор точек
//  ptCount - [вх] количество точек
//
void shiftHwToOrigin(nbPointHw *pt, uint32_t ptCount) {
   nbPointHw shift = {pt[0].x, pt[0].y, 0, 0};
   // Найти минимальные координаты
   for (uint32_t i=1; i<ptCount; ++i) {
      if (shift.x > pt[i].x) shift.x = pt[i].x;
      if (shift.y > pt[i].y) shift.y = pt[i].y;
   }
   // Выполнить сдвиг
   for (uint32_t i=0; i<ptCount; ++i) {
      pt[i].x -= shift.x;
      pt[i].y -= shift.y;
   }
}

/****************************************************************************
** Быстрое преобразование Фурье
****************************************************************************/

//назначение: вычисление коэффициентов ряда Фурье для заданной двумерной выборки
//параметры:
//  pt	      - [вх] массив элементов с двухмерной выборкой
//  ptCount   - [вх] количество точек
//  coefs     - [вых]указатель на массив коэффициентов ряда Фурье
//  coefsCount- [вх] количество вычисляемых коэффициентов уменьшенное в 4 раза
//
void fftHw512SpecR32(const nbPointHw pt[], int32_t ptCount, float coefs[], int32_t coefsCount) {
  // (кол-во эл-тов принимает значения 512, 256, 170, 128,
  // кол-во элементов в таблице 512
  // поэтому нужно промасштабировать кол-во эл-тов до размера таблицы)
	float *cur_coef = coefs;
	float xcos, xsin, ycos, ysin;

	if (ptCount == psnHW_SCALE_COUNT || ptCount == psnHW_SCALE_COUNT/2 || ptCount == psnHW_SCALE_COUNT/4) {
    // ТОЧНОЕ ВЫЧИСЛЕНИЕ ЗНАЧЕНИЙ
    int32_t k = psnHW_SCALE_COUNT / ptCount;	// масштабирующий коэффициент для вычисления sin и cos по таблице
	
    // цикл вычисления коэффициентов функции
		for(int32_t  i=1, ik = k ; i <= coefsCount; i++, ik += k) {
			
			xcos = 0.0f; xsin = 0.0f; ycos = 0.0f; ysin = 0.0f;

      // цикл суммирования
			for(int32_t j = 0, ijk = 0; j < ptCount; j++, ijk += ik) {
        // вычисление sin и cos при помощи таблицы
				float asin = gTableSin[ ijk % psnHW_SCALE_COUNT];	//значение sin угла
				float acos = gTableCos[ ijk % psnHW_SCALE_COUNT];	//значение cos угла

				xcos += pt[j].x * acos;
				xsin += pt[j].x * asin;
				ycos += pt[j].y * acos;
				ysin += pt[j].y * asin;
			}

      // сохранение коэффициентов
			*(cur_coef+0) = xcos;
			*(cur_coef+1) = xsin;
			*(cur_coef+2) = ycos;
			*(cur_coef+3) = ysin;
			cur_coef +=4;
		}		
	} else {
    // ПРИБЛИЖЕННОЕ ВЫЧИСЛЕНИЕ (для 170 точек) (погрешность = 0.008)
		int32_t k = (psnHW_SCALE_COUNT<<16) / ptCount;	//масштабирующий коэффициент для вычисления sin и cos по таблице	

    // цикл вычисления коэффициентов функции
		for(int32_t  i= 1, ik = k ; i <= coefsCount; i++, ik += k) {
			xcos = 0.0f; xsin = 0.0f; ycos = 0.0f; ysin = 0.0f;
      // цикл суммирования
			for(int32_t j = 0, ijk = 1<<15; j < ptCount; j++, ijk += ik) {
				//вычисление sin и cos при помощи таблицы
				//float asin = gTableSin[ HIWORD(ijk) % psnHW_SCALE_COUNT];	//значение sin угла
				//float acos = gTableCos[ HIWORD(ijk) % psnHW_SCALE_COUNT];
				
				float dArg2Pi = ((float)(j*i)/ptCount)*2.0f*MATH_PI;
        float dsin = (float)sin(dArg2Pi);
				float dcos = (float)cos(dArg2Pi);
				
				xcos += pt[j].x * dcos;
				xsin += pt[j].x * dsin;
				ycos += pt[j].y * dcos;
				ysin += pt[j].y * dsin;
			}

      // сохранение коэффициентов
			*(cur_coef+0) = xcos;
			*(cur_coef+1) = xsin;
			*(cur_coef+2) = ycos;
			*(cur_coef+3) = ysin;
			cur_coef +=4;
		}
	}

  // нахождение среднего значения для всех коэфф.
	float back = 1.0f / ptCount;
	float *end_coef = coefs + coefsCount*4;
	for(cur_coef = coefs; cur_coef != end_coef; cur_coef++) {
		*cur_coef *= back;
	}
}

//назначение: быстрое преобразование Фурье для вектора точек
//параметры:
//  pt  - [вх]  512 точек исходного образа
//  w   - [вых] выходной вектор 416 непрерывных вещественных значений в формате nbVBP_FORMAT_R32
//
void fftHw512ToW416R32(const nbPointHw *pt, Vbp &w) {
  nbPointHw *buf = new nbPointHw[psnHW_SCALE_COUNT + psnHW_SCALE_COUNT/2]; // массив для хранения временных координат
  float     *pos = w.r32; // указатель на позицию, в которую записываются новые коэфф.
	
  // Заполнить массив массива buff = [512 эл-тов pt][256 нач. эл-тов pt]
  // Копировать исходные данные
	memcpy(buf, pt, psnHW_SCALE_COUNT*sizeof(nbPointHw));
  // Дублировать начало выборки в конец массива для расчета без доп. перемещений
	memcpy(buf + psnHW_SCALE_COUNT, pt, (psnHW_SCALE_COUNT/2)*sizeof(nbPointHw));

  // Вычислить коэффициенты Фурье для разных частей выборок
  // Вычислить на половине
	int i;
  for( i = 0; i < 2; i++) {
		fftHw512SpecR32(buf+i*(psnHW_SCALE_COUNT/2),psnHW_SCALE_COUNT,pos,16);
		pos += 16*4;
	}

  // Вычислить на четверти
  for( i = 0; i < 4; i++) {
		fftHw512SpecR32(buf+i*(psnHW_SCALE_COUNT/4),psnHW_SCALE_COUNT/2,pos,8);
		pos += 8*4;
	}

  // Вычислить на шестой части
  for( i = 0; i < 6; i++) {
		fftHw512SpecR32(buf+i*(psnHW_SCALE_COUNT/6),psnHW_SCALE_COUNT/3,pos,4);
		pos += 4*4;
	}

  // Вычислить на восьмой
  for( i = 0; i < 8; i++) {
		fftHw512SpecR32(buf+i*(psnHW_SCALE_COUNT/8),psnHW_SCALE_COUNT/4,pos,2);
		pos += 2*4;
	}

  delete[] buf;
	//после выполнения всех операций, массив coeffs  
	//заполнен 416 значениями коэффициентов
	//416 = 16*4*2 + 8*4*4 + 4*4*6 + 2*4*8  
}

/****************************************************************************
** БЫСТРОЕ ПРЕОБРАЗОВАНИЕ ФУРЬЕ ДЛЯ ДАВЛЕНИЯ
****************************************************************************/

//назначение: вычисление коэффициентов ряда Фурье для заданной одномерной выборки
//параметры:
//  pt	      - [вх] массив элементов
//  ptCount   - [вх] количество точек
//  coefs     - [вых]указатель на массив коэффициентов ряда Фурье
//  coefsCount- [вх] количество вычисляемых коэффициентов уменьшенное в 2 раза
//
void fftHw512P64R32(const nbPointHw pt[], int32_t ptCount, float coefs[], int32_t coefsCount){
  // (кол-во эл-тов принимает значения 512, 256, 170, 128,
  // кол-во элементов в таблице 512
  // поэтому нужно промасштабировать кол-во эл-тов до размера таблицы)
  float *cur_coef = coefs;
  float pcos, psin;

  if (ptCount == psnHW_SCALE_COUNT || ptCount == psnHW_SCALE_COUNT/2 || ptCount == psnHW_SCALE_COUNT/4) {
    // ТОЧНОЕ ВЫЧИСЛЕНИЕ ЗНАЧЕНИЙ
    int32_t k = psnHW_SCALE_COUNT / ptCount;	// масштабирующий коэффициент для вычисления sin и cos по таблице

    // цикл вычисления коэффициентов функции
    for(int32_t  i=1, ik = k ; i <= coefsCount; i++, ik += k) 
    {
      pcos = 0.0f; psin = 0.0f;

      // цикл суммирования
      for(int32_t j = 0, ijk = 0; j < ptCount; j++, ijk += ik) {
        // вычисление sin и cos при помощи таблицы
        float asin = gTableSin[ ijk % psnHW_SCALE_COUNT];	// значение sin угла
        float acos = gTableCos[ ijk % psnHW_SCALE_COUNT];	// значение cos угла

        pcos += pt[j].p * acos;
        psin += pt[j].p * asin;
      }

      //сохранение коэффициентов
      *(cur_coef+0) = pcos;
      *(cur_coef+1) = psin;
      cur_coef +=2;
    }		
  } else {
    // ПРИБЛИЖЕННОЕ ВЫЧИСЛЕНИЕ (для 170 точек) (погрешность = 0.008)
    int32_t k = (psnHW_SCALE_COUNT<<16) / ptCount;	// масштабирующий коэффициент для вычисления sin и cos по таблице

    // цикл вычисления коэффициентов функции
    for(int32_t  i= 1, ik = k ; i <= coefsCount; i++, ik += k) {
      pcos = 0.0f; psin = 0.0f;
      // цикл суммирования
      for(int32_t j = 0, ijk = 1<<15; j < ptCount; j++, ijk += ik) {
        float dArg2Pi = ((float)(j*i)/ptCount)*2.0f*MATH_PI;
        float dsin = (float)sin(dArg2Pi);
        float dcos = (float)cos(dArg2Pi);

        pcos += pt[j].x * dcos;
        psin += pt[j].x * dsin;
      }

      // сохранение коэффициентов
      *(cur_coef+0) = pcos;
      *(cur_coef+1) = psin;
      cur_coef +=2;
    }
  }

  // нахождение среднего значения для всех коэфф.
  float back = 1.0f / ptCount;
  float *end_coef = coefs + coefsCount*2;
  for(cur_coef = coefs; cur_coef != end_coef; cur_coef++) {
    *cur_coef *= back;
  }
}

//назначение: быстрое преобразование Фурье для вектора точек
//параметры:
//  pt     - [вх]  512 точек исходного образа
//  w      - [вых] выходной вектор psnFFT_COEF_COUNT+psnP_COEF_COUNT непрерывных вещественных значений в формате nbVBP_FORMAT_R32
//  shift  - [вх]  смещение для записи коэффициентов давления
//
void fftHw512PToW64R32(const nbPointHw *pt, Vbp &w, uint32_t shift) {
  nbPointHw *buf = new nbPointHw[psnHW_SCALE_COUNT + psnHW_SCALE_COUNT/2]; // массив для хранения временных координат
  float     *pos = w.r32+shift; // указатель на позицию, в которую записываются новые коэфф.

  // Заполнить массив массива buff = [512 эл-тов pt][256 нач. эл-тов pt]
  // Копировать исходные данные
  memcpy(buf, pt, psnHW_SCALE_COUNT*sizeof(nbPointHw));
  // Дублировать начало выборки в конец массива для расчета без доп. перемещений
  memcpy(buf + psnHW_SCALE_COUNT, pt, (psnHW_SCALE_COUNT/2)*sizeof(nbPointHw));

  // Вычислить коэффициенты Фурье для разных частей выборок
  // Вычислить на половине
  for(int i = 0; i < 2; i++) {
    fftHw512P64R32(buf+i*(psnHW_SCALE_COUNT/2),psnHW_SCALE_COUNT,pos,16);
    pos += 16*2;
  }

  delete [] buf;
  //после выполнения всех операций, массив coeffs  
  //заполнен 64 значениями коэффициентов
  //64 = 16*2*2
}
