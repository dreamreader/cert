//////////////////////////////////////////////////////////////////////////
//файл:         nbTypes.h
//версия:
//дата:
//изменен:
//автор:
//
//цель:         Содержит объявление основных простых типов данных НПБК
//              и операций над ними
//
//  СВОЙ  one's own,                                      baseOwn
//  ЧУЖОЙ somebody else's, another's, strange, foreign    baseForeign
//  ВСЕ   all                                             baseAll
//  РАЗЛИЧНЫЙ various                                     baseVarious
//
//////////////////////////////////////////////////////////////////////////

#ifndef _NB_TYPES_H
#define _NB_TYPES_H

#include "nbBase.h"

//.............................................................................
//  ОСНОВНЫЕ ТИПЫ ДАННЫХ
//.............................................................................

#pragma pack(1)

//.............................................................................

//Описатель программного интерфейса компонента
typedef void*         nbHandle;

//Нулевое значение или нулевой описатель
#ifdef __cplusplus
#define nbNULL        0
#else
#define nbNULL        ((void*)0)
#endif

//.............................................................................
//
//  Блок данных с определенной длиной и концевым ограничителем
//    nbData ::= *Данные
//    Блок_данных ::= Длина Данные Терм
//      Длина ::= uint32_t(Данные)
//      Данные::= uint8_t
//      Терм  ::= uint16_t(0x0000)
//  Примечания (русские символы занимают 6 байт каждый):
//  - Размер строки в байтах располагается по отрицательному смещению
//    и занимает 4 байта
//  - Используется для представления строк в кодировке UTF-8, т.к.
//    = Это международный промышленный стандарт (RFC 3629 и ISO/IEC 10646 Annex D)
//    = Кодирует все символы на свете
//    = Нет неоднозначностей (как BE/LE в UTF-16)
//    = Позволяет быстро находить строки в произвольной части текста
//    = Легко распознается эвристически
//    = Компактнее UTF-7, UTF-16, UTF-32
//    = Является надмножеством ASCII (чистый, 7-битный ASCII - это тоже UTF-8)
typedef uint8_t*      nbData; 

//.............................................................................

//Уникальный универсальный идентификатор
//примечания:
//  Соответствует стандарту ИСО/МЭК 9834-8.
typedef struct nbUuid_t {
  uint32_t d1;
  uint16_t d2;
  uint16_t d3;
  uint8_t  d4[8];
} nbUuid;

//Ссылка на УУИД
#if defined(__cplusplus)
  #define nbRefUuid const nbUuid &  
#else
  #define nbRefUuid const nbUuid * const
#endif

//Нулевой идентификатор
//{00000000-0000-0000-0000-000000000000}
static const nbUuid nbUUID_NIL = 
{ 0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}};

//.............................................................................
//  ДАТА И ВРЕМЯ
//.............................................................................

//Дата и время
//  - Имеет особенности
//    = Соответствует ИСО/МЭК 8601:2004 Data elements and interchange formats — Information interchange — Representation of dates and times 
//    = Соответствует спецификации POSIX для UNIX-подобных систем.
//     Хранит число секунд, прошедших с 1 января 1970 года (начало эпохи).
//    = Поддерживает 64-битные платформы
//    = Допустимо использовать для обратного отсчета дат и времени до 1970 года, путем использования отрицат. значений
typedef int64_t   nbTime;

//.............................................................................

//Время ожидания в микросекундах
typedef uint32_t  nbTimeout;

#define nbTIMEOUT_INFINITE                          ((nbTimeout)-1)   //  До завершения запроса.
#define nbTIMEOUT_NO_WAIT                           (0)               //  Без ожидания.

//.............................................................................

//Тип даты и времени
typedef uint8_t   nbTimeType;

#define nbTIME_CREATE                               (1)   //  Дата создания.
#define nbTIME_LAST_MODIFY                          (2)   //  Дата модификации.
#define nbTIME_LAST_ACCESS                          (3)   //  Дата последнего использования (загрузки).
#define nbTIME_EXPIRITE                             (4)   //  Дата истечения срока действия.
#define nbTIME_ERROR_I                              (9)   //  Дата последней ошибки первого рода.
#define nbTIME_ERROR_II                             (10)  //  Дата последней ошибки второго рода.

//.............................................................................
//  БИОМЕТРИЧЕСКИЕ ПАРАМЕТРЫ
//.............................................................................

//Тип ограничения
typedef uint16_t nbConstraintType;

//Значение параметра

#define nbCT_DATA                         (1)  //  Значение параметра "Неизвестный" для эмуляции
#define nbCT_DATA_OWN                     (2)  //  Значение параметра "Свой" для обучения
#define nbCT_DATA_ALL                     (3)  //  Значение параметра "Чужой" для обучения

//Ограничения, устанавливаемые для векторов биометрических параметров

#define nbCT_SIGMA                        (4)   //  Размер сигмы распределения н.б.п. (для нормального закона)
#define nbCT_INTERVAL                     (5)   //  Интервал (макс.-мин. значения) для д.б.п.
#define nbCT_DISPLACEMENT                 (6)   //  Смещение распределения "Чужие" относительно центра ОДЗ
#define nbCT_DISCRETE_STEP                (7)   //  Шаг дискретизации в ОДЗ, считая с нижней границы
#define nbCT_RANGE_LIMIT                  (8)   //  Максимальное по модулю учитываемое значение б.п. (актуально для дискретных величин)
#define nbCT_OWN_LAW                      (9)   //  Закон распределения величин образов "Свой" для б.п.
#define nbCT_ALL_LAW                      (10)  //  Закон распределения образов "Чужой" для б.п.

//Ограничения, устанавливаемые для блоков преобразования

#define nbCT_ALGORITHM                    (11)  //  Алгоритм преобразования
#define nbCT_SALT                         (12)  //  Соль (случайное число)
#define nbCT_ERROR_DETECTION_RATE         (13)  //  Число обнаруживаемых ошибок
#define nbCT_ERROR_CORRECTION_RATE        (14)  //  Число исправляемых ошибок
#define nbCT_CRYPTO_STRENGTH_REDUCTION    (15)  //  Предельный уровень снижения стойкости (бит)
#define nbCT_CONN_ID                      (16)  //  Идентификатор соединения, связанный с входным параметром слота

//.............................................................................

//Формат хранения биометрического параметра
typedef uint8_t nbMetaFormat;

#define nbMF_ANY        (0)     // Любой числовой тип.
#define nbMF_I1         (0+1)   // Знак. Значения [-1,+1].
#define nbMF_I2         (0+2)   // Целое число длиной 2 бита. Значения: [-2..1].
#define nbMF_I4         (0+3)   // Целое число длиной 4 бита. Значения: [-8..7].
#define nbMF_I8         (0+4)   // Целое число длиной 1 байт. Соответствует типу int8_t.
#define nbMF_I16        (0+5)   // Целое число длиной 2 байта. Соответствует типу int16_t.
#define nbMF_I32        (0+6)   // Целое число длиной 4 байта. Соответствует типу int32_t.
#define nbMF_I64        (0+7)   // Целое число длиной 8 байт. Соответствует типу int64_t.
#define nbMF_U1         (16+1)  // Бит. Значения [0,1].
#define nbMF_U2         (16+2)  // Неотрицательное целое число длиной 2 бита. Значения [0..3].
#define nbMF_U4         (16+3)  // Неотрицательное целое число длиной 4 бита. Значения [0..15].
#define nbMF_U8         (16+4)  // Неотрицательное целое число длиной 1 байт. Соответствует типу uint8_t.
#define nbMF_U16        (16+5)  // Неотрицательное целое число длиной 8 байт. Соответствует типу uint16_t.
#define nbMF_U32        (16+6)  // Неотрицательное целое число длиной 8 байт. Соответствует типу uint32_t.
#define nbMF_U64        (16+7)  // Неотрицательное целое число длиной 8 байт. Соответствует типу uint64_t.
#define nbMF_R16        (32+5)  // Короткое вещественное число (1-бит знак, 5-бит экспонента, 10-бит мантисса).
#define nbMF_R32        (32+6)  // Вещественное число одинарной точности(согласно IEEE 753-1985). Соответствует float.
#define nbMF_R64        (32+7)  // Вещественное число с двойной точностью (согласно IEEE 753-1985). Соответствует double.

//.............................................................................

//Тип биометрического параметра
typedef uint8_t nbMetaType;

#define nbMT_ANY                        (0)  // Любой
#define nbMT_CONTINUOUS                 (1)  // Непрерывный
#define nbMT_DISCRETE                   (3)  // Дискретный
#define nbMT_CONTINUOUS_OWN             (5)  // Непрерывный, неизменяемый по области "Свой"
#define nbMT_DISCRETE_OWN               (6)  // Дискретный, неизменяемый по области "Свой"

//.............................................................................

//Метаописание ВБП в матрице ВБП
typedef struct nbMeta_t {
  uint32_t      count;      //  число биометрических параметров в векторе (ограничено 0..65535)
  nbMetaFormat  format;     //  формат биометрических параметров (физический размер)
  nbMetaType    type;       //  тип биометрических параметров (интерпретация)
} nbMeta;

//.............................................................................

//Вектор биометрических параметров (интерпретируется в зависимости от формата)
typedef void*   nbVbp;

//.............................................................................

//Матрица векторов биометрических параметров
//примечание:
//  Число частей не должно быть больше 65535, так как значения больше имеют спец.
//  интерпретацию.
//  Типы матрицы 
//  1) empty (пустая) - определен стандартом
//  2) full (полная)  - определен стандартом
//  3) pattern (шаблон) - определен стандартом
//  4) guid (глобальный идентификатор базы образов при хранении на диске) - для след. версий, но должен обраб.
//  5) pointer (указатель интерфейса для доступа к базе) - для след. версий, но должен обраб.
//  возможна передача матрицы по значению (by val) и по ссылке (by ref)
typedef struct nbMatrix_t {
  uint32_t      nrows;    //  число частей в каждом примере
  uint32_t      ncols;    //  число примеров
  nbMeta        *meta;    //  вектор заголовков однородных частей ВБП (nbMeta[nrows])
  nbVbp         **data;   //  ВБП по ссылке(nbVbp[nrows][ncols])
} nbMatrix;

//.............................................................................

//Текущее состояние элементарного преобразователя
typedef uint8_t nbBlockState;

#define nbBS_UNTRAINED             (0)  //  Элементарный преобразователь не обучен.

#define nbBS_TRAINED               (1)  //  Элементарный преобразователь обучен.

#define nbBS_PARTIALLY_TRAINED     (2)  //  Частично обученный вложенный преобразователь.
//.............................................................................

//Флаги состояния блока в П-Схеме
//  примечание: I - обучающая выборка
//              O - обучаемая выборка
//
typedef uint16_t nbBlockFlags;

#define nbBF_NONE                   (0x0000)  //  Отсуствие флагов

#define nbBF_EXCLUDE_UNUSED         (0x0001)  //  Блок может быть исключен из схемы
  // флаг используется перед обучением и используется во время экспорта:
  // - если разработчик биометрического приложения может исключить блок из схемы
  // - если блок автоматически исключается из схемы, если для него не задаются спец. параметры

#define nbBF_PROTECTED              (0x0002)  //  Защищенный блок
  //Флаг используется:
  // - для ограничения прямого доступа к характеристикам и свойствам блока преобразования;
  // - для указания, что характеристики блока подверглись модификации,
  //   препятствующей или делающей невозможным их изучение

#define nbBF_HIDDEN                 (0x0004)  //  Скрытый слот
  //ограничение доступа к выходным (специальным выходным) параметрам блока,
  //а также к дообучению через явный вызов функции PostTrain.


#define nbBF_TWINCONTAINER          (0x0008)  //  Разделение параметров преобразования на общедоступную и закрытую
  //Нестандартизированный флаг. Используется для разделения контейнера на 2: открытый (public) и закрытый (private).
  //Если установлен, то формируется второй (закрытый) контейнер, содержащий ключевую информацию для восстановления данных первого контейнера.
  //Во время экспорта оба контейнера размещаются непосредственно друг за другом раздельно
  //По умолчанию информационные блоки записываются в открытый контейнер.
  //Частный контейнер может содержать пропуски блоков, т.к. порядок считывания определяется по первому контейнеру.

#define nbBF_THROUGH                (0x0010)  //  Не изменяет выходные (по направлению обучения) параметры.
  //флаг используется перед обучением:
  // - если установлен, то I <=> O или O <=> I
  //   и перед обучением должен быть задан только параметр I
  // - если не установлен, обучаемый параметр O должен быть известен,
  //   если только не генерируется внутри блока
  // - флаг может изменяться после каждого обучения (дообучения)

#define nbBF_GENERATOR              (0x0020)  //  Генерирует выходные параметры (по направлению к обучению)
                                              //  и может перевыделять память выходных параметров, если не хватает числа примеров,
                                              //  в противном случае использует число примеров, переданное для обучения
                                              //  Выходной параметр по направлению обучения может быть не определен, т.к. генерируется
  //флаг используется перед обучением:
  // - если обучаемый параметр, генерируется внутри блока O1,O2,O3
  // - если обучаемый параметр вычисляется на основе входа I
  // - иначе параметр должен быть определен до начала обучения (дообучения)
  // - !при переобучении должны быть переучены НА ТОМ ЖЕ СОСТОЯНИИ все связанные с ним блоки
  // - если одновременно с THROUGH, изменяется и вход и выход причем не обязательно идентично

#define nbBF_BACKWARD_TRAIN         (0x0040)  //  Используется обратное обучение
  //флаг используется перед обучением:
  // - если используется обратное обучение O<-I вместо I->O, например, в индикаторах и блоках связывания

#define nbBF_ITERATIVE_TRAIN        (0x0080)  //  Используется итерационное обучение
  //флаг используется перед обучением:
  // - если обучение является многопроходным процессом, каждый шаг которого состоит из двух фаз
  //   (1) на первой результаты вычисления со входов подаются на выход
  //   (2) на второй фазе результаты вычисления с выходов подаются на вход
  //   на каждом шаге осуществляется попытка достичь желаемых коэффициентов на выходе.
  //   (результаты промежуточных вычислений пишутся в слоты o2, а финальных в слоты o)
  //   в зависимости от настройки комбинации флагов THROUGH и GENERATOR 
  //   блок может модифицировать помимо своих внутренних характеристик 
  //   на каждом шаге входы, выходы или и то и другое.


//.............................................................................

//Тип блока НБК
//  диапазоны:
//    0         - неопределенный блок
//    1..63     - зарезервированный блок преобразования
//    64..127   - блок преобразования (информационный) разработчика НПБК
//    128..191  - зарезервированный блок информации
//    192..254  - блок информации разработчика биометрического приложения
//    255       - блок, является продолжением предыдущего блока
typedef uint8_t nbBlockType;

#define nbBT_NBC                  (0)  // Нейросетевой биометрический контейнер.
// - заголовок первого блока контейнера
// - загружается весь блок целиком, но разбираются только поддерживаемые контейнером блоки

#define nbBT_1                    (1)  // Номер первого блока преобразования (или информационного) разработчиков НПБК

#define nbBT_NEURAL_NET_CONVERTER (127)  // Преобразователь на базе ИНС.
#define nbBT_FUZZY_CONVERTER      (126)  // Нечеткий преобразователь.
#define nbBT_CRYPTO_CONVERTER     (125)  // Преобразователь, использующий криптографические преобразования.
#define nbBT_HARD_INDICATOR       (124)  // Жесткий индикатор.
#define nbBT_SOFT_INDICATOR       (123)  // Мягкий индикатор.
#define nbBT_ERROR_SPECTATOR      (122)  // Блок обнаружения и исправления ошибок.
#define nbBT_CONNECTOR            (121)  // Блок связывания и размножения ошибок.
#define nbBT_BIO_AUDITOR          (120)  // Блок данных для аудита.
#define nbBT_FUZZY_ADDRESSER      (119)  // Блок нечеткой адресации.
// примечание: может использоваться для нечеткой адресации по базе биометрических образов
// - последовательным сравнением
// - путем формирования в узлах дерева поиска вспомогательных контейнеров
// - путем использования и и. и а. нескольких технологий
#define nbBT_CODE_TRANSFORMER     (118) // Блок трансформации (выходного) кода.
// примечание:
// - по умолчанию располагается последним в схеме преобразования
// - может изменять режим обучения в случае дообучения на новом коде преобразования
// - переобучение осуществляется путем задания старого выходного кода и нового
//    (или только нового, если выполнена эмуляция)
// - нельзя переученный с помощью трансформатора кода блок использовать
//   для передачи в центр тестирования
//   В центр тестирования должен быть 
//      а.передан НБК, обученный на тех же образах, но другом ключе
//      б.только отклики контейнера, обученного на другом ключе, так как
//        при проявлении ключа, зная алгоритм CODE_TRANSFORMER можно с большой вероятностью
//        восстановить любой новый ключ: 
//        шаг 1. по тестовому ключу восстанавливаем выход предыдущего блока,
//        шаг 2. по выходу предыдущего блока и текущему алгоритму CT получаем текущий ключ контейнера
//   В центр тестирования может передаваться и измененный с помощью CT ключ, если 
//   CT использует следующую формулу трансформации отклика I
//      H(I,s1) ^ D1 = O1
//      H(I,s2) ^ D2 = O2
//    Всего 3 варианта, при котором выполняется переобучение:
//    1.  устанавливаем старый входной код и новый выходной код
//    2.  устанавливаем старый выходной код и новый выходной код
//    3.  выполняем эмуляцию и получаем старые входной, выходной коды, устанавливаем новый выходной код
//    с точки зрения безопасности нужно передавать старый входной код,
//    но откуда разработчик получит его непонятно
//    т.е. он должен разобрать схему, установить обработчик старого кода
//    получить и запомнить его, а потом, при необходимости устанавливать как параметр обучения
//    Значит в функции SetCodeTransformator нужно устанавливать только новый код,
//    а старый устанавливать и получать через SetProperty.

#define nbBT_SECURITY             (117)  // Блок безопасности (могут устанавливаться параметры ключа.
// примечание:
// - расположен в конце контролируемого блока
// - может хранить контрольную сумму блока, хэш-значение, эцп
// - второй и следующие блоки безопасности задаются извне разработчиками биометрического приложения
// - первый блок безопасности относится к контейнеру, если указан в схеме преобразования
// - теоретически может зашифровывать данные контейнера, если допустимо выполнение дешифрование на ключе//)
//   PostTrain(TYPE_SECURITY,PUBLIC), PostTrain(TYPE_SECURITY,PROTECTED)
// - для критических параметров может рассчитываться контрольная сумма,
// - а для некритических контрольная сумма либо не рассчитывается, либо располагается перед вторым блоком crc

#define nbBT_CONDITION            (116) //Условный преобразователь

#define nbBT_2                    (128) // Номер первого информационного блока разработчиков биометрического приложения

#define nbBT_NBC_ID               (254) // Идентификатор НБК.
#define nbBT_USER_ID              (253) // Идентификатор пользователя.
#define nbBT_DATE                 (252) // Даты.
#define nbBT_BIO_TECH             (251) // Биометрическая технология.
  //располагается в любом месте
  //содержит информацию о числе подтверждаемых блоков (заголовок считается отдельным блоком)
#define nbBT_CSCHEME              (250) // Схема преобразования (Convert-Scheme).
#define nbBT_TEST_RESPONSE        (249) // Блок выхода (используется для хранения информации о результатах тестирования).

#define nbBT_EXTENSION            (255) // Расширение предыдущего блока, если его данные не умещаются в 1 блок.

//СТРУКТУРА БЛОКОВ В ПАМЯТИ
//
//  nbBT_NBC_ID
//    [nbBlockHeader][uint8_t]+
//
//  nbBT_USER_ID
//    [nbBlockHeader][uint8_t]+
//
//  nbBT_DATE
//    [nbBlockHeader]([nbTimeType][nbTime])+
//
//  nbBT_CSCHEME
//    [nbNbcBlockHeader]([i]|[b])+
//    i ::= [nbSlotID][nbMeta]
//    b ::= [nbSlotID][nbMeta][nbBlockFlags][nbBlockState][count]([nbSlotID])count
//
//    порядок в схеме      ::= [вых.слот]([вх.слот])+([спец.вх]*[спец.вых]*[блок преобр])+
//    порядок в ссыл.блока ::= ([вх.слот]|[вых.блока])+(спец.вх.|спец.вых.другого блока|спец.вх.др.блока)*(спец.вых.)*
//    
//
//  nbBT_SECURITY
//    [nbBlockHeader][contrCount][formatOwner][formatType]([uint8_t])+
//    zone    ::= [int16_t]  число контроллируемых блоков
//                           (заголовок НБК считается отдельным блоком)
//    owner   ::= [uint16_t] владелец формата
//    format  ::= [uint16_t] тип
//    Все блоки преобразования, указанные в схеме преобразования относятся к изменяемым
//    НПБК, остальные блоки (внешние по отношению к ним) - изменяются разработчиками биометрических приложений.
//    Нейросетевой преобразователь может изменять контрольные суммы контейнера,
//    например, в случае выполнения функции SetCodeTransformator. 
//    В этом случае все контрольные суммы должны быть пересчитаны (в том числе и внешние)
//    
//
//    confirmCount - число блоков (заголовок контейнера), которые контроллируются блоком
//    Допустимо формировать несколько блоков nbBT_SECURITY,
//    каждый из которых контроллирует и заверяет все блоки, расположенные до него в НПБК
//    Если format owner = 0 и format type = 0, то используется нестандартизированный алгоритм 
//    проверки целостности контейнера, реализованный НПБК
//
//  nbBT_TEST_RESPONSE
//    [nbBlockHeader][nbTestMode tm][nbPurpose p][nbMatrix m][nbSlotID ids]*
//    (блок формируется во время экспорта отдельного блока контейнера, в обычном контейнере может не исп.)
//
//    tm            - режим тестирования (планируется расширение на будущее)
//    p             - цель
//    m             - результаты
//    ids           - номера слотов, с которых снимались значения
//
//  nbBT_BIO_TECH
//    [nbBlockHeader]([nbUuid bimType][nbUuid providerId][nbUuid processorId][n][[slot]])*
//    bimType     - тип биометрического образа, используемый в преобразовании (или nbUUID_NIL)
//    providerId  - идентификатор компонента ввода биометрического образа (или nbUUID_NIL)
//                  (биометрический образ может быть сформирован с помощью другого компонента)
//    processorId - идентификатор обработчика биометрического образа в nbMatrix (или nbUUID_NIL)
//                  (матрица ВБП должна быть сформирована именно с помощью этого обработчика или сгенерирована)
//    n           - число выходов процессора для которых производится связывание
//    slot        - номер связанного слота для данных (или nbSLOT_OUT, если вход пропускается)

//.............................................................................

//Цель получения биометрического образа
//(представляется как набор признаков, которые могут использоваться совместно)
typedef uint8_t   nbPurpose;

#define nbPURPOSE_UNKNOWN           (0x00)  // Цель неизвестна.
#define nbPURPOSE_AUTHENTICATE      (0x01)  // Аутентификация (сопоставление 1:1).
#define nbPURPOSE_ENTER						  (0x02)  // Вхождение в группу (поиск в базе 1:oo).
#define nbPURPOSE_IDENTIFY					(0x04)  // Идентификация для обучения.
#define nbPURPOSE_AUDIT						  (0x08)  // Для аудита или тестирования.

#define nbPURPOSE_MULTI_USER			  (0x10)  // Содержит биометрические образы (ВБП) разных пользователей.
#define nbPURPOSE_MULTI_IMAGE				(0x20)  // Содержит отличающиеся биометрические образы (ВБП).
#define nbPURPOSE_BALANCED					(0x40)  // Содержит сбалансированную базу биометрических образов (ВБП).
#define nbPURPOSE_SYNTHETIC					(0x80)  // Содержит синтетические образы (ВБП).

//.............................................................................

//Режим обучения
typedef uint16_t nbTrainMode;

#define nbTRAIN_MODE_DEFAULT        (0x0000)  //  Нормальный режим обучения.
#define nbTRAIN_MODE_WITHOUT_FLAGS  (0x1000)  //  Со сбросом флагов.
#define nbTRAIN_MODE_WITHOUT_STATE  (0x2000)  //  Без смены состояния.
#define nbTRAIN_MODE_CHECK_ONLY     (0x8000)  //  Только проверка корректности параметров.

//Предлагается заменить флаг nbTRAIN_MODE_WITHOUT_FLAGS на
//  nbTRAIN_MODE_SET_FLAGS и nbTRAIN_MODE_RESET_FLAGS, иначе придется считывать текущее состояние слота
//
//

//.............................................................................

//Заголовок блока НБК
typedef struct nbBlockHeader_t {
  uint16_t        sizeLo;       // Младшее слово размера блока без заголовка
  uint8_t         sizeHi;       // Старший байт размера блока без заголовка
  nbBlockType  blockType;       // Тип блока
} nbBlockHeader;

//.............................................................................

//Тело блока заголовка НБК
//  – УУИД типа нейросетевого контейнера определяет разработчик НПБК. 
//    Идентификатор должен полностью определять формат хранения параметров
//    во всех блоках НБК и их допустимые значения. 
//  - УУИД типа можно выбирать равным УУИД компонента НПБК
typedef struct nbNbcBody_t {
  uint32_t        size;         // полная длина в байтах НБК
  nbUuid          nbcType;      // УУИД типа нейросетевого контейнера.
} nbNbcBody;

//.............................................................................
//  СХЕМА ОБРАБОТКИ/ТРАНСФОРМАЦИИ/ПРЕОБРАЗОВАНИЯ/ПОИСКА ДАННЫХ
//.............................................................................

//Номер слота (входной, выходной, специальный входной/выходной параметр, блок преобразования)
//уникальный в пределах схемы преобразования
//[2 бита][14 бит]
//  тип    индекс
typedef uint16_t nbSlotID;

#define   nbSLOT_MASK_TYPE        (0xC000)  //  Маска типа слота
#define   nbSLOT_MASK_INDEX       (0x3FFF)  //  Маска абсолютного номера слота
#define   nbSLOT_MASK_BTYPE       (0x3F80)  //  Маска типа блока преобразования для выходных слотов
#define   nbSLOT_MASK_BINDEX      (0x007F)  //  Маска индекса преобразования для выходных слотов

#define   nbSLOT_TYPE_IN          (0x0000)  //  Входной биометрический параметр или выходной параметр
#define   nbSLOT_TYPE_SPEC_IN     (0x4000)  //  Специальный входной параметр
#define   nbSLOT_TYPE_SPEC_OUT    (0x8000)  //  Специальный выходной параметр
#define   nbSLOT_TYPE_CONV        (0xC000)  //  Выходной параметр блока преобразования (т.е. сам блок)

#define   nbSLOT_OUT              (nbSlotID)(0x0000)                              //  Номер слота выходного кода
#define   nbSLOT_IN(i)            (nbSlotID)(0x3FFF&i)                            //  Номер входного слота
#define   nbSLOT_SPEC_IN(i)       (nbSlotID)(0x4000|(0x3FFF&i))                   //  Номер спец. вх. слота
#define   nbSLOT_SPEC_OUT(o)      (nbSlotID)(0x8000|(0x3FFF&o))                   //  Номер спец. вых. слота
#define   nbSLOT_CONV(bt,i)       (nbSlotID)(0xC000|(0x3F80&(bt<<7))|(0x007F&i))  //  Номер слота блока преобразования 1..127
#define   nbSLOT_CONV_DEFAULT(bt) (nbSlotID)(0xC000|(0x3F80&(bt<<7)))             //  Номер слота блока преобразования "по умолчанию"

//ТРЕБОВАНИЯ К СХЕМЕ-ПРЕОБРАЗОВАНИЯ
//  1.Номера слотов уникальны в пределах схемы-преобразования (начальной или конечной),
//  т.е. максимальное число слотов равно 2^14-зарезервированные значения "по умолчанию"
//
//  2.Схема преобразования должна содержать описания слотов в следующем порядке:
//  - нотация схемы: [вых.][вх.]..[вх.][спец.вх.]..[спец.вых][блок][блок][блок]
//  - блоки в схеме расположены в порядке их вызова во время эмуляции (тестирования)
//  - нотация для связей блока: [парам]
//      [вх.][вх.][вх.][спец.вх.этого типа блока][спец.вых.этого типа блока]
//      [вх.]..[вх.][спец.вх]..[спец.вх.][спец.вых]..[спец.вых]
//
//  3.По умолчанию необходимо нумеровать номера слотов в возрастающем порядке, начиная с
//    первого в группе и ссылаться на них согласно порядку сортировки.
//
//  4.После обучения (дообучения) и первого экспорта избыточные слоты может проводиться
//  редукция (упрощение схемы), то есть удаляться неиспользуемые слоты.
//  Правила удаления зависят от типа слота:
//  - вых.биом.слот не удаляется никогда;
//  - вх.биом. слоты не удаляются никогда (изменяются только при установке схемы);
//  - спец.вх. слоты могут удаляться кратные слоты со старшими адресами (т.е. они просто не устанавливаются)
//      или в случае, если они не устанавливаются вовсе (т.е. в них нет потребности);
//      (см. спецификацию схемы для отдельных слотов)
//  - спец.вх. слоты удаляются, если не используются и блок преобразования поддерживает
//      их отсутствие;
//      (см. спецификацию схемы для отдельных слотов)
//  - блоки преобразования исключаются автоматически НПБК,
//      если они не были обучены до момента экспорта НБК и установлен флаг
//      nbBLOCK_FLAG_DELETE_UNUSED, кроме того блоки преобразования автоматически удаляют
//      связанные только с ними неиспользуемые спец.вх.,спец.вых. слоты
//  - у блоков, использующих исключенные слоты, они удаляются из списка связей таким образом,
//    что следующие слоты смещаются к начальным, занимая позицию удаленного.
//    (опционально может вводиться дополнительный слот "заглушка" (0,0,0))
//
//  5.Правила нумерации слотов зависят от типа слотов
//  - при исключении слотов НПБК или разработчиком номера других слотов не меняются;
//  - допустимо заменять в блоках преобразования ссылки от (на) нескольких слотов на один слот,
//    исключая ненужные из схемы
//
//ПОДГРАФЫ БЛОКОВ ПРЕОБРАЗОВАНИЯ В СХЕМЕ-ПРЕОБРАЗОВАНИЯ
//
//  nbBT_NEURAL_NET_CONVERTER
//
//  [bi]|
//  [bi]-[NN]-[bo]
//  [bi]|
//
//  nbBT_FUZZY_CONVERTER
//
//  [bi]|
//  [bi]-[FU]-[bo]
//  [bi]|
//
//  nbBT_CRYPTO_CONVERTER
//       [si]?
//         |
//  [bi]-[CR]-[bo]
//  
//
//  nbBT_HARD_INDICATOR
//
//  [bi]-[HI]
//
//  nbBT_SOFT_INDICATOR
//   [si][si][si]
//  [bi]||||
//  [bi]-[SI]
//  [bi]|
//  nbBT_ERROR_DETECTOR and CORRECTOR
//
//  [bi]-[ED]-[bo]?
//         ||
//       [de][ce]2
//
//  nbBT_CONNECTOR
//  [si][si][si]*
//       |||
//  [bi]-[C]-[bo]
//        |
//       [so]*
//
//
//  nbBT_AUDITOR
//
//  [si][si][si] <=> [bi][bi][bi]
//  [bi]||||
//  [bi]-[BA]
//  [bi]| |
//       [so]?
//
//  nbBT_FUZZY_ADDRESSER
// 
//  [bi]|
// +[bi]-[FA]
//  [bi]| |
//       [so]
//
//  nbBLOCK_CODE_TRANSFORMER
//
//  [bi]-[CT]-[bo]
//
//  nbBT_TESTER
//  [bi]|
// +[bi]-[BA]
//  [bi]||||
//   [so][so][so]*
//
// примечание:
//  1. если блок преобразования не имеет вых.кода, поле meta устанавливается в nbMeta(0,0,0)

//.............................................................................

////Описание слота параметра
//typedef struct nbSlotPrm_t {
//  nbSlotID  id;       //  идентификатор параметра
//  nbMeta    meta;     //  метаописание параметра
//} nbSlotPrm;

////Описание слота преобразования
//typedef struct nbSlotConv_t {
//  nbSlotID  id;       //  идентификатор параметра
//  nbMeta    meta;     //  метаописание параметра
//  nbBlockFlags flags; //  флаги элементарного преобразователя
//  nbBlockState state; //  состояние элементарного преобразователя
//  uint8_t   count;    //  число связанных слотов
//  nbSlotID  conn[1];  //  идентификаторы связанных слотов [0..255]
//} nbSlotConv;

//.............................................................................

//Состояние НПБК
//примечание:
//  1. в функции Reset указываются сбрасываемые флаги состояния НПБК
//  2. при сбросе флага TRAINED схема устанавливается в исходное состояние
//      (может исп. для сброса всех состояний)
typedef uint16_t nbNbccState;
#define nbNS_INITIAL                  (0x0000)  //  состояние в котором находится НПБК по умолчанию
#define nbNS_ALL                      (nbNS_TRAINED|nbNS_CSCHEME|nbNS_SPEC_IN|nbNS_CRITICAL_IN|nbNS_CRITICAL_OUT|nbNS_SPEC_OUT)  //  полный набор сбрасываемых состояний
#define nbNS_TRAINED                  (0x0001)  //  I   - блоки преобразования обучены (1) / не обучены (0);
#define nbNS_CSCHEME                  (0x0002)  //  II  - схема преобразования определена (1) / не определена (0);
#define nbNS_SPEC_IN                  (0x0004)  //  III - специальные входные параметры установлены (1) / не установлены (0);
#define nbNS_SPEC_OUT                 (0x0008)  //  IV  - специальные выходные параметры, а также промежуточные вычисления получены (1) / не получены (0).
#define nbNS_CRITICAL_IN              (0x0010)  //  V   - входные параметры "Свой" и результаты промежут. вычислений известны (1) / не известны (0);
#define nbNS_CRITICAL_OUT             (0x0020)  //  VI  - выходной код известен (1) / не известен (0);

//.............................................................................

//Режим тестирования
typedef uint16_t nbTestMode;        

#define nbTEST_MODE_E1_BIO                        (1)   //  Оценка вероятности ошибки первого рода
#define nbTEST_MODE_E2_BIO                        (2)   //  Оценка вероятности ошибки второго рода
#define nbTEST_MODE_E2_BIO_HUMAN_COMPROMISED      (3)   //  Оценка вероятности ошибки второго рода при скомпрометированном ключе
                                                        //  (скомпрометировано общее представление данных, например, парольная фраза)
                                                        //  (косвенная компрометация при передаче от человека человеку)
#define nbTEST_MODE_E2_BIO_COMPROMISED            (4)   //  Оценка ошибки второго рода на полностью скомпрометированном ключе
                                                        //  (полная компрометация: известен точный образ, но не вся выборка, иначе стойкость равна 0)
                                                        //  (биометрический аудитор позволяет исключить подбор одинаковых образов)
                                                        //  (если после использования биометрический образ изменяется, вероятность может быть большой)
#define nbTEST_MODE_E2_CODE                       (5)   //  Оценка вероятности ошибки второго рода при подборе ключа
                                                        //  (эффективна длина выходного кода или сложность подбора индикатора)
#define nbTEST_MODE_E2_BIO_WHITE_NOISE            (6)   //  Оценка вероятности ошибки второго рода при подборе ключа
                                                        //  с помощью белого шума
#define nbTEST_MODE_E2_BIO_CORR_NOISE             (7)   //  Оценка вероятности ошибки второго рода при подборе ключа
                                                        //  с помощью шума, учитывающего особенности распределения биометрических данных
#define nbTEST_MODE_E2_CONV                       (8)   //  Оценка вероятности стойкости через изменение параметров

//...........................................................................
//  Результаты тестирования в соответствии с TestMode
//...........................................................................
struct nbTestResult {
  float e1Bio;                //  Оценка вероятности ошибки первого рода
  float e2Bio;                //  Оценка вероятности ошибки второго рода
  float e2HumanCompromised;   //  Оценка вероятности ошибки второго рода при скомпрометированном ключе
  float e2BioCompromised;     //  Оценка ошибки второго рода на полностью скомпрометированном ключе
  float e2Code;               //  Оценка вероятности ошибки второго рода при подборе ключа
  float e2BioWhiteNoise;      //  Оценка вероятности ошибки второго рода при подборе ключа
  float e2BioCorrNoise;       //  Оценка вероятности ошибки второго рода при подборе ключа
  float e2Conv;               //  Оценка вероятности стойкости через изменение параметров
};

//.............................................................................
//
//СПЕЦИФИКАЦИЯ ФАЙЛА, хранящего биометрический контейнер
//
// *.nbc
//
//  [signature][nbc]
//
//  signature        = uint32_t ("NBC " )
//
//.............................................................................

//.............................................................................
//
//СПЕЦИФИКАЦИЯ ФАЙЛА, хранящего матрицы биометрических образов
//
// *.vbpm
//
//  [signature][processor cid][user id][bim type][vbp matrix]
//
//  signature        = uint32_t ("VBPM")
//  bim type         = nbUuid (тип биометрических образов, из которых получена матрица биометрических параметров)
//  user id          = nbUuid (nbUUID_NIL или идентификатор пользователя)
//  processorCid     = nbUuid (идентификатор процессора, с помощью которого получена матрица)
//  vbp matrix       = nbMatrix
//.............................................................................

typedef struct nbMatrixFileHeader_t {
  uint32_t  signature;
  nbUuid    bimType;
  nbUuid    providerCid;
  nbUuid    processorCid;
  nbUuid    userId;
} nbMatrixFileHeader;

#pragma pack()

#endif
